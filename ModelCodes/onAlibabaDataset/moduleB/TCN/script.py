# This file has been autogenerated by version 1.53.0 of the Azure Automated Machine Learning SDK.


import numpy
import numpy as np
import pandas as pd
import pickle
import argparse


# For information on AzureML packages: https://docs.microsoft.com/en-us/python/api/?view=azure-ml-py
from azureml.training.tabular._diagnostics import logging_utilities


def setup_instrumentation(automl_run_id):
    import logging
    import sys

    from azureml.core import Run
    from azureml.telemetry import INSTRUMENTATION_KEY, get_telemetry_log_handler
    from azureml.telemetry._telemetry_formatter import ExceptionFormatter

    logger = logging.getLogger("azureml.training.tabular")

    try:
        logger.setLevel(logging.INFO)

        # Add logging to STDOUT
        stdout_handler = logging.StreamHandler(sys.stdout)
        logger.addHandler(stdout_handler)

        # Add telemetry logging with formatter to strip identifying info
        telemetry_handler = get_telemetry_log_handler(
            instrumentation_key=INSTRUMENTATION_KEY, component_name="azureml.training.tabular"
        )
        telemetry_handler.setFormatter(ExceptionFormatter())
        logger.addHandler(telemetry_handler)

        # Attach run IDs to logging info for correlation if running inside AzureML
        try:
            run = Run.get_context()
            return logging.LoggerAdapter(logger, extra={
                "properties": {
                    "codegen_run_id": run.id,
                    "automl_run_id": automl_run_id
                }
            })
        except Exception:
            pass
    except Exception:
        pass

    return logger


automl_run_id = 'AutoML_b6d0762b-afc7-45ac-86d3-b3627e86c47f_HD_0'
logger = setup_instrumentation(automl_run_id)


def split_dataset(X, y, weights, split_ratio, should_stratify):
    '''
    Splits the dataset into a training and testing set.

    Splits the dataset using the given split ratio. The default ratio given is 0.25 but can be
    changed in the main function. If should_stratify is true the data will be split in a stratified
    way, meaning that each new set will have the same distribution of the target value as the
    original dataset. should_stratify is true for a classification run, false otherwise.
    '''
    from sklearn.model_selection import train_test_split

    random_state = 42
    if should_stratify:
        stratify = y
    else:
        stratify = None

    if weights is not None:
        X_train, X_test, y_train, y_test, weights_train, weights_test = train_test_split(
            X, y, weights, stratify=stratify, test_size=split_ratio, random_state=random_state
        )
    else:
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, stratify=stratify, test_size=split_ratio, random_state=random_state
        )
        weights_train, weights_test = None, None

    return (X_train, y_train, weights_train), (X_test, y_test, weights_test)


def get_training_dataset(dataset_id):
    '''
    Loads the previously used dataset.
    
    It assumes that the script is run in an AzureML command job under the same workspace as the original experiment.
    '''
    
    from azureml.core.dataset import Dataset
    from azureml.core.run import Run
    
    logger.info("Running get_training_dataset")
    ws = Run.get_context().experiment.workspace
    dataset = Dataset.get_by_id(workspace=ws, id=dataset_id)
    return dataset.to_pandas_dataframe()


def prepare_data(dataframe):
    '''
    Prepares data for training.
    
    Cleans the data, splits out the feature and sample weight columns and prepares the data for use in training.
    This function can vary depending on the type of dataset and the experiment task type: classification,
    regression, or time-series forecasting.
    '''
    
    from azureml.training.tabular.preprocessing import data_cleaning
    
    logger.info("Running prepare_data")
    label_column_name = '__time__'
    
    # extract the features, target and sample weight arrays
    y = dataframe[label_column_name].values
    X = dataframe.drop([label_column_name], axis=1)
    sample_weights = None
    X, y, sample_weights = data_cleaning._remove_nan_rows_in_X_y(X, y, sample_weights,
     is_timeseries=True, target_column=label_column_name)
    
    return X, y, sample_weights


def generate_data_transformation_config():
    from azureml.training.tabular.featurization._featurization_config import FeaturizationConfig
    from azureml.training.tabular.featurization.timeseries.category_binarizer import CategoryBinarizer
    from azureml.training.tabular.featurization.timeseries.missingdummies_transformer import MissingDummiesTransformer
    from azureml.training.tabular.featurization.timeseries.numericalize_transformer import NumericalizeTransformer
    from azureml.training.tabular.featurization.timeseries.restore_dtypes_transformer import RestoreDtypesTransformer
    from azureml.training.tabular.featurization.timeseries.time_index_featurizer import TimeIndexFeaturizer
    from azureml.training.tabular.featurization.timeseries.time_series_imputer import TimeSeriesImputer
    from azureml.training.tabular.featurization.timeseries.timeseries_transformer import TimeSeriesPipelineType
    from azureml.training.tabular.featurization.timeseries.timeseries_transformer import TimeSeriesTransformer
    from azureml.training.tabular.featurization.timeseries.unique_target_grain_dropper import UniqueTargetGrainDropper
    from collections import OrderedDict
    from numpy import dtype
    from numpy import nan
    from pandas.core.indexes.base import Index
    from sklearn.pipeline import Pipeline
    
    transformer_list = []
    transformer1 = UniqueTargetGrainDropper(
        cv_step_size=800,
        max_horizon=300,
        n_cross_validations=5,
        target_lags=[0],
        target_rolling_window_size=0
    )
    transformer_list.append(('unique_target_grain_dropper', transformer1))
    
    transformer2 = MissingDummiesTransformer(
        numerical_columns=['func_ID']
    )
    transformer_list.append(('make_numeric_na_dummies', transformer2))
    
    transformer3 = TimeSeriesImputer(
        end=None,
        freq='N',
        impute_by_horizon=False,
        input_column=['func_ID'],
        limit=None,
        limit_direction='forward',
        method=OrderedDict([('ffill', [])]),
        option='fillna',
        order=None,
        origin=None,
        value={'func_ID': 3810.0}
    )
    transformer_list.append(('impute_na_numeric_datetime', transformer3))
    
    transformer4 = RestoreDtypesTransformer(
        dtypes={'func_ID': dtype('int64'), 'runtime': dtype('O'), '_automl_target_col': dtype('int64')},
        target_column='_automl_target_col'
    )
    transformer_list.append(('restore_dtypes_transform', transformer4))
    
    transformer5 = NumericalizeTransformer(
        categories_by_col={'runtime': Index(['custom', 'custom-container', 'debian8', 'dotnetcore2.1', 'golang1.8', 'java11', 'java8', 'nodejs10',
               'nodejs12', 'nodejs4.4', 'nodejs6', 'nodejs8', 'php7.2', 'python2.7', 'python3'],
              dtype='object')},
        exclude_columns=set(),
        include_columns=set()
    )
    transformer_list.append(('make_categoricals_numeric', transformer5))
    
    transformer6 = TimeIndexFeaturizer(
        correlation_cutoff=0.99,
        country_or_region=None,
        datetime_columns=None,
        force_feature_list=None,
        freq='N',
        holiday_end_time=None,
        holiday_start_time=None,
        overwrite_columns=True,
        prune_features=True
    )
    transformer_list.append(('make_time_index_featuers', transformer6))
    
    transformer7 = CategoryBinarizer(
        columns=[],
        drop_first=False,
        dummy_na=False,
        encode_all_categoricals=False,
        prefix=None,
        prefix_sep='_'
    )
    transformer_list.append(('make_categoricals_onehot', transformer7))
    
    pipeline = Pipeline(steps=transformer_list)
    tst = TimeSeriesTransformer(
        country_or_region=None,
        drop_column_names=[],
        featurization_config=FeaturizationConfig(
            blocked_transformers=None,
            column_purposes=None,
            dataset_language=None,
            prediction_transform_type=None,
            transformer_params=None
        ),
        force_time_index_features=None,
        freq='N',
        grain_column_names=None,
        group=None,
        lookback_features_removed=False,
        max_horizon=300,
        origin_time_colname='origin',
        pipeline=pipeline,
        pipeline_type=TimeSeriesPipelineType.FULL,
        seasonality=1,
        time_column_name='idx',
        time_index_non_holiday_features=[],
        use_stl=None
    )
    
    return tst
    
    
def generate_algorithm_config():
    '''
    Specifies the actual algorithm and hyperparameters for training the model.
    
    It is the last stage of the final scikit-learn pipeline. For ensemble models, generate_preprocessor_config_N()
    (if needed) and generate_algorithm_config_N() are defined for each learner in the ensemble model,
    where N represents the placement of each learner in the ensemble model's list. For stack ensemble
    models, the meta learner generate_algorithm_config_meta() is defined.
    '''
    from azureml.contrib.automl.dnn.forecasting.wrapper.forecast_tcn_wrapper import ForecastTCNWrapper
    from azureml.contrib.automl.dnn.forecasting.wrapper.forecast_wrapper import DNNParams
    from forecast.losses import QuantileLoss
    from pandas._libs.tslibs.offsets import Nano
    
    algorithm = ForecastTCNWrapper()
    algorithm.params = DNNParams(
        params={'num_epochs': 100, 'lookback': 8, 'max_horizon': 300, 'batch_size': 256, 'primary_metric': 'normalized_root_mean_squared_error', 'enable_future_regressors': False, 'learning_rate': 0.0001, 'num_cells': 3, 'multilevel': 'CELL', 'depth': 1, 'num_channels': 64, 'dropout_rate': 0.25, 'dilation': 2, 'future_layers': 0, 'future_expansion_factor': 1, 'EARLY_STOPPING_MIN_IMPROVEMENTS': 0.001, 'LR_DECAY_FACTOR': 0.5, 'MIN_GRAIN_SIZE_FOR_EMBEDDING': 10, 'EMBEDDING_TARGET_CALC_TYPE': 'ROOT', 'EMBEDDING_MULT_FACTOR': 0.05, 'EMBEDDING_ROOT': 4, 'n_layers': 3, 'loss': QuantileLoss(
            quantiles=[0.10000000149011612, 0.25, 0.5, 0.75, 0.8999999761581421]
        ), 'device': 'cpu', 'consume_distributed_featurization_output': False, 'automl_settings': {'enable_early_stopping': True, 'enable_ensembling': True, 'enable_stack_ensembling': False, 'ensemble_iterations': 15, 'enable_onnx_compatible_models': False, 'save_mlflow': True, 'max_cores_per_iteration': -1, 'send_telemetry': True, 'blacklist_algos': ['TensorFlowDNN', 'TensorFlowLinearRegressor'], 'whitelist_models': ['TCNForecaster'], 'compute_target': 'GenCluster', 'enable_dnn': True, 'enable_code_generation': True, 'experiment_exit_score': None, 'experiment_timeout_minutes': 7200, 'featurization': 'auto', 'hyperdrive_config': None, 'grain_column_names': None, 'is_timeseries': True, 'iteration_timeout_minutes': 7200, 'max_concurrent_iterations': 2, 'metric_operation': 'minimize', 'model_explainability': True, 'n_cross_validations': 5, 'name': 'TCN-4-ColdStart', 'path': './sample_projects/TCN-4-ColdStart', 'primary_metric': 'normalized_root_mean_squared_error', 'region': 'eastus2', 'resource_group': 'Genterist', 'subscription_id': 'bfe17904-50af-42dd-b5e8-bf39d98a45ab', 'task_type': 'regression', 'validation_size': None, 'test_size': None, 'vm_type': 'STANDARD_E4DS_V4', 'workspace_name': 'Genterist-Workspace', 'label_column_name': '__time__', 'max_horizon': 300, 'country_or_region': None, 'cv_step_size': 800, 'freq': 'N', 'target_aggregation_function': None, 'time_column_name': 'idx', 'enable_batch_run': True, 'dataset_id': 'e18cab13-77de-466a-b6b1-4cd2b15b0d25', 'target_lags': [0], 'target_rolling_window_size': 0, 'drop_column_names': [], 'seasonality': 1, 'arimax_raw_columns': ['func_ID', 'runtime', 'idx']}, 'grain_column_names': None, 'apply_log_transform_for_label': True, 'current_epoch': 73},
        required=['learning_rate', 'lookback', 'batch_size', 'num_epochs', 'loss', 'device', 'primary_metric']
    )
    
    return algorithm
    
    


def train_model(X, y, transformer=None):
    
    logger.info("Running train_model")
    
    df = transformer.transform(X, y).sort_index()
    y = df[['_automl_target_col']]
    X = df.drop(columns=['_automl_target_col'])
    model = generate_algorithm_config()
    model.train(n_epochs=100, X_train=X, y_train=y, featurizer=transformer)
    return model


def calculate_metrics(model, X, y, sample_weights, X_test, y_test, cv_splits=None):
    '''
    Calculates the metrics that can be used to evaluate the model's performance.
    
    Metrics calculated vary depending on the experiment type. Classification, regression and time-series
    forecasting jobs each have their own set of metrics that are calculated.'''
    
    from azureml.training.tabular.preprocessing._dataset_binning import get_dataset_bins
    from azureml.training.tabular.score.scoring import score_forecasting
    from azureml.training.tabular.score.scoring import score_regression
    
    y_pred, _ = model.forecast(X_test)
    y_min = np.min(y)
    y_max = np.max(y)
    y_std = np.std(y)
    
    bin_info = get_dataset_bins(cv_splits, X, None, y)
    regression_metrics_names, forecasting_metrics_names = get_metrics_names()
    metrics = score_regression(
        y_test, y_pred, regression_metrics_names, y_max, y_min, y_std, sample_weights, bin_info)
    
    try:
        horizons = X_test['horizon_origin'].values
    except Exception:
        # If no horizon is present we are doing a basic forecast.
        # The model's error estimation will be based on the overall
        # stddev of the errors, multiplied by a factor of the horizon.
        horizons = np.repeat(None, y_pred.shape[0])
    
    featurization_step = generate_data_transformation_config()
    grain_column_names = featurization_step.grain_column_names
    time_column_name = featurization_step.time_column_name
    
    forecasting_metrics = score_forecasting(
        y_test, y_pred, forecasting_metrics_names, horizons, y_max, y_min, y_std, sample_weights, bin_info,
        X_test, X, y, grain_column_names, time_column_name)
    metrics.update(forecasting_metrics)
    return metrics


def get_metrics_names():
    
    regression_metrics_names = [
        'explained_variance',
        'mean_absolute_percentage_error',
        'mean_absolute_error',
        'root_mean_squared_log_error',
        'spearman_correlation',
        'r2_score',
        'predicted_true',
        'residuals',
        'median_absolute_error',
        'root_mean_squared_error',
    ]
    forecasting_metrics_names = [
        'forecast_mean_absolute_percentage_error',
        'forecast_residuals',
        'forecast_table',
        'forecast_adjustment_residuals',
    ]
    return regression_metrics_names, forecasting_metrics_names


def get_metrics_log_methods():
    
    metrics_log_methods = {
        'explained_variance': 'log',
        'forecast_mean_absolute_percentage_error': 'Skip',
        'forecast_table': 'Skip',
        'mean_absolute_percentage_error': 'log',
        'mean_absolute_error': 'log',
        'forecast_adjustment_residuals': 'Skip',
        'forecast_residuals': 'Skip',
        'root_mean_squared_log_error': 'log',
        'spearman_correlation': 'log',
        'r2_score': 'log',
        'predicted_true': 'log_predictions',
        'residuals': 'log_residuals',
        'median_absolute_error': 'log',
        'root_mean_squared_error': 'log',
    }
    return metrics_log_methods


def main(training_dataset_id=None):
    '''
    Runs all functions defined above.
    '''
    
    from azureml.automl.core.inference import inference
    from azureml.core.run import Run
    from azureml.training.tabular.score._cv_splits import _CVSplits
    from azureml.training.tabular.score.scoring import aggregate_scores
    
    import mlflow
    
    # The following code is for when running this code as part of an AzureML script run.
    run = Run.get_context()
    
    df = get_training_dataset(training_dataset_id)
    X, y, sample_weights = prepare_data(df)
    tst = generate_data_transformation_config()
    tst.fit(X, y)
    ts_param_dict = tst.parameters
    short_series_dropper = next((step for key, step in tst.pipeline.steps if key == 'grain_dropper'), None)
    if short_series_dropper is not None and short_series_dropper.has_short_grains_in_train and grains is not None and len(grains) > 0:
        # Preprocess X so that it will not contain the short grains.
        dfs = []
        X['_automl_target_col'] = y
        for grain, df in X.groupby(grains):
            if grain in short_series_processor.grains_to_keep:
                dfs.append(df)
        X = pd.concat(dfs)
        y = X.pop('_automl_target_col').values
        del dfs
    cv_splits = _CVSplits(X, y, frac_valid=None, CV=5, n_step=800, is_time_series=True, task='regression', timeseries_param_dict=ts_param_dict)
    scores = []
    for X_train, y_train, sample_weights_train, X_valid, y_valid, sample_weights_valid in cv_splits.apply_CV_splits(X, y, sample_weights):
        partially_fitted_model = train_model(X_train, y_train, transformer=tst)
        metrics = calculate_metrics(partially_fitted_model, X, y, sample_weights, X_test=X_valid, y_test=y_valid, cv_splits=cv_splits)
        scores.append(metrics)
        print(metrics)
    model = train_model(X_train, y_train, transformer=tst)
    
    metrics = aggregate_scores(scores)
    metrics_log_methods = get_metrics_log_methods()
    print(metrics)
    for metric in metrics:
        if metrics_log_methods[metric] == 'None':
            logger.warning("Unsupported non-scalar metric {}. Will not log.".format(metric))
        elif metrics_log_methods[metric] == 'Skip':
            pass # Forecasting non-scalar metrics and unsupported classification metrics are not logged
        else:
            getattr(run, metrics_log_methods[metric])(metric, metrics[metric])
    cd = inference.get_conda_deps_as_dict(True)
    
    # Saving ML model to outputs/.
    signature = mlflow.models.signature.infer_signature(X, y)
    mlflow.pytorch.log_model(
        pytorch_model=model,
        artifact_path='outputs/',
        conda_env=cd,
        signature=signature,
        pickle_module=pickle)
    
    run.upload_folder('outputs/', 'outputs/')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--training_dataset_id', type=str, default='e18cab13-77de-466a-b6b1-4cd2b15b0d25',     help='Default training dataset id is populated from the parent run')
    args = parser.parse_args()
    
    try:
        main(args.training_dataset_id)
    except Exception as e:
        logging_utilities.log_traceback(e, logger)
        raise